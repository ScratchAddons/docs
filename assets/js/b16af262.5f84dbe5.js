"use strict";(self.webpackChunkdocusaurus_2_classic_template=self.webpackChunkdocusaurus_2_classic_template||[]).push([[9784],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>m});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function d(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),i=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},s=function(e){var t=i(e.components);return n.createElement(p.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,p=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),c=i(a),b=r,m=c["".concat(p,".").concat(b)]||c[b]||u[b]||l;return a?n.createElement(m,o(o({ref:t},s),{},{components:a})):n.createElement(m,o({ref:t},s))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=b;var d={};for(var p in t)hasOwnProperty.call(t,p)&&(d[p]=t[p]);d.originalType=e,d[c]="string"==typeof e?e:r,o[1]=d;for(var i=2;i<l;i++)o[i]=a[i];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}b.displayName="MDXCreateElement"},6875:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>d,toc:()=>i});var n=a(7462),r=(a(7294),a(3905));const l={title:"addon.tab.traps (Traps)",toc_title:"addon.tab.traps",h1_title:"`addon.tab.traps` (Traps)",description:"addon.tab.traps is a public API for userscripts that can be used to obtain objects that are not otherwise available.",weight:1,aliases:["/docs/developing/addon.tab.traps"]},o=void 0,d={unversionedId:"reference/addon-api/addon.tab/addon.tab.traps",id:"reference/addon-api/addon.tab/addon.tab.traps",title:"addon.tab.traps (Traps)",description:"addon.tab.traps is a public API for userscripts that can be used to obtain objects that are not otherwise available.",source:"@site/develop/reference/addon-api/addon.tab/addon.tab.traps.md",sourceDirName:"reference/addon-api/addon.tab",slug:"/reference/addon-api/addon.tab/addon.tab.traps",permalink:"/develop/reference/addon-api/addon.tab/addon.tab.traps",draft:!1,tags:[],version:"current",frontMatter:{title:"addon.tab.traps (Traps)",toc_title:"addon.tab.traps",h1_title:"`addon.tab.traps` (Traps)",description:"addon.tab.traps is a public API for userscripts that can be used to obtain objects that are not otherwise available.",weight:1,aliases:["/docs/developing/addon.tab.traps"]},sidebar:"tutorialSidebar",previous:{title:"addon.tab.redux (Redux)",permalink:"/develop/reference/addon-api/addon.tab/addon.tab.redux"},next:{title:"Addon Manifest",permalink:"/develop/reference/addon-manifest"}},p={},i=[{value:"Examples",id:"examples",level:2},{value:"Trap terminology",id:"trap-terminology",level:2},{value:"Trappable Object",id:"trappable-object",level:2},{value:"<code>addon.tab.traps.onceValues</code>",id:"addontabtrapsoncevalues",level:2},{value:"<code>addon.tab.traps.getBlockly</code>",id:"addontabtrapsgetblockly",level:2},{value:"<code>addon.tab.traps.getPaper</code>",id:"addontabtrapsgetpaper",level:2},{value:"<code>addon.tab.traps.getInternalKey</code>",id:"addontabtrapsgetinternalkey",level:2},{value:"Events",id:"events",level:2}],s={toc:i};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"This page is out of date and is in need of a rewrite. If you know anything about traps, please contribute!")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"addon.tab.traps")," is a public API for userscripts that can be used to obtain objects that are not otherwise available. The actual traps are coded at ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ScratchAddons/ScratchAddons/blob/master/content-scripts/prototype-handler.js"},"prototype-handler"),"."),(0,r.kt)("p",null,'They share some APIs with "Once" traps, but is very different and is documented at ',(0,r.kt)("a",{parentName:"p",href:"Fake-redux-state"},"Fake redux state")," separately.  "),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://github.com/ScratchAddons/ScratchAddons/blob/master/addons/editor-stepping/userscript.js"},"editor-stepping")," addon shows how to manipulate ",(0,r.kt)("inlineCode",{parentName:"p"},"Thread")," object trapped."),(0,r.kt)("h2",{id:"trap-terminology"},"Trap terminology"),(0,r.kt)("p",null,'There are two types of traps, named after how many times they get trapped. Singleton instance like VM or ScratchBlocks get trapped only once per trap, so they are called "Once". Objects like Thread can get trapped multiple times, so they are called "Many".'),(0,r.kt)("p",null,"Difference between Once and Many is simple: the addon only stores reference for Once."),(0,r.kt)("h2",{id:"trappable-object"},"Trappable Object"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Trap name"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"),(0,r.kt)("th",{parentName:"tr",align:null},"Once/Many"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"vm"),(0,r.kt)("td",{parentName:"tr",align:null},"Scratch VM, trapped by Function.prototype.bind"),(0,r.kt)("td",{parentName:"tr",align:null},"Once")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"vm.propsVMBind"),(0,r.kt)("td",{parentName:"tr",align:null},"Scratch VM, trapped from props.vm using bind"),(0,r.kt)("td",{parentName:"tr",align:null},"Once")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"vm.propsVMAssign"),(0,r.kt)("td",{parentName:"tr",align:null},"Scratch VM, trapped from props.vm using assign"),(0,r.kt)("td",{parentName:"tr",align:null},"Once")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"thread"),(0,r.kt)("td",{parentName:"tr",align:null},"Thread object used in Scratch VM"),(0,r.kt)("td",{parentName:"tr",align:null},"Many")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"ScratchBlocks"),(0,r.kt)("td",{parentName:"tr",align:null},"ScratchBlocks object"),(0,r.kt)("td",{parentName:"tr",align:null},"Once")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"workspace"),(0,r.kt)("td",{parentName:"tr",align:null},"ScratchBlocks workspace"),(0,r.kt)("td",{parentName:"tr",align:null},"Once")))),(0,r.kt)("h2",{id:"addontabtrapsoncevalues"},(0,r.kt)("inlineCode",{parentName:"h2"},"addon.tab.traps.onceValues")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"onceValues")," attribute of ",(0,r.kt)("inlineCode",{parentName:"p"},"addon.tab.traps"),' stores references for "Once" traps. It is an prototypeless object - e.g. you cannot call ',(0,r.kt)("inlineCode",{parentName:"p"},"onceValues.hasOwnProperty()"),"."),(0,r.kt)("p",null,'Keys are the "trap name" listed above, and values are the trapped values.'),(0,r.kt)("p",null,"Example: to get VM object, use ",(0,r.kt)("inlineCode",{parentName:"p"},"addon.tab.traps.onceValues.vm")),(0,r.kt)("h2",{id:"addontabtrapsgetblockly"},(0,r.kt)("inlineCode",{parentName:"h2"},"addon.tab.traps.getBlockly")),(0,r.kt)("table",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Return value"),(0,r.kt)("td",null,(0,r.kt)("code",null,"Promise<object>"))),(0,r.kt)("td",null,"Promise rejects if"),(0,r.kt)("td",null,"The addon isn't running on a project")),(0,r.kt)("p",null,"Gets the instance of Blockly being used by Scratch.\nThis is different from ",(0,r.kt)("inlineCode",{parentName:"p"},"window.Blockly"),"."),(0,r.kt)("h2",{id:"addontabtrapsgetpaper"},(0,r.kt)("inlineCode",{parentName:"h2"},"addon.tab.traps.getPaper")),(0,r.kt)("table",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Return value"),(0,r.kt)("td",null,(0,r.kt)("code",null,"Promise<object>"))),(0,r.kt)("td",null,"Promise rejects if"),(0,r.kt)("td",null,"The addon isn't running on a project, or if Paper couldn't be found")),(0,r.kt)("p",null,"Gets the instance of Paper being used by Scratch. (@scratch/paper)"),(0,r.kt)("h2",{id:"addontabtrapsgetinternalkey"},(0,r.kt)("inlineCode",{parentName:"h2"},"addon.tab.traps.getInternalKey")),(0,r.kt)("table",null,(0,r.kt)("tr",null,(0,r.kt)("th",null,"Parameter"),(0,r.kt)("th",null,"Type"),(0,r.kt)("th",null,"Required"),(0,r.kt)("th",null,"Description")),(0,r.kt)("tr",null,(0,r.kt)("td",null,"element"),(0,r.kt)("td",null,(0,r.kt)("code",null,"HTMLElement")),(0,r.kt)("td",null,"Yes"),(0,r.kt)("td",null,"The reference element"))),(0,r.kt)("table",null,(0,r.kt)("tr",null,(0,r.kt)("td",null,"Return value"),(0,r.kt)("td",null,(0,r.kt)("code",null,"String")))),(0,r.kt)("p",null,"Gets the internal key for React."),(0,r.kt)("h2",{id:"events"},"Events"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"addon.tab.traps")," itself is not an ",(0,r.kt)("inlineCode",{parentName:"p"},"EventTarget"),". However, it's possible to add or remove listeners, by using some public APIs. ",(0,r.kt)("inlineCode",{parentName:"p"},"traps.addOnceListener"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"removeOnceListener"),' is for "Once" traps, and ',(0,r.kt)("inlineCode",{parentName:"p"},"addManyListener"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"removeManyListener"),' is for "Many" traps. Note that listeners for "Once" objects can fire multiple times under some conditions, and may never fire if the object is trapped before loading the userscript.'),(0,r.kt)("p",null,"These methods work like ",(0,r.kt)("inlineCode",{parentName:"p"},"addEventListener"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"removeEventListener"),", but third argument is not supported at all. The first argument is for trap name; for example, if it needs to be fired when ",(0,r.kt)("inlineCode",{parentName:"p"},"thread")," is trapped, do ",(0,r.kt)("inlineCode",{parentName:"p"},'addManyListener("thread", callback)'),". The second argument is callback function that can take one argument for CustomEvent object, which contains the trapped value."),(0,r.kt)("p",null,"The CustomEvent object passed to callback always has ",(0,r.kt)("inlineCode",{parentName:"p"},"value")," attribute for trapped value, and may have ",(0,r.kt)("inlineCode",{parentName:"p"},"trapName")," if the first argument for the listener is ",(0,r.kt)("inlineCode",{parentName:"p"},"*")," (see below)."),(0,r.kt)("p",null,"Special event: if the trap name passed to these methods is ",(0,r.kt)("inlineCode",{parentName:"p"},"*"),", it will fire when any object for the category is trapped. For example, callback in ",(0,r.kt)("inlineCode",{parentName:"p"},'addOnceListener("*", callback)')," gets fired whenever an object in Once category is trapped. To check what is trapped, the CustomEvent passed to the callback also has ",(0,r.kt)("inlineCode",{parentName:"p"},"trapName")," attribute for the trap name."))}c.isMDXComponent=!0}}]);